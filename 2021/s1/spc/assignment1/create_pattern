#!/bin/bash
# Loop for as many input arguments are given
while [[ $1 -gt 0 ]] ;
	# store the newest parameter
	current=$1
	# shift the parameters down once
	shift;

	# Read what the newest parameter was
	do
		# If it was -n, store the next parameter (the shift index)
		if [[ $current = "-n" ]]
		then
			parameter=$1
		fi

		# If it was -u, remember this for later
		if [[ $current = "-u" ]] ;
		then
			upper=true ;
		fi
done

# The cyclic pattern repeats after 26 so calculate the remainder of the input divided by 26
# Note this is more efficient but unnecessary
let parameter=$(expr $parameter % 26)

# Create either an upper or lower case alphabet based on the input parameter
if [[ $upper = "true" ]] # Upper Case:
then
	# create an array going from A to Z
	alphabet=({A..Z})
else # Lower Case:
	# create an array going from a to z
	alphabet=({a..z})
fi

# returns the letter of the alphabet corresponding to the input number
span_one_start=${alphabet[@]:$parameter:1}	
# returns the last letter of the alphabet (always either 'Z' or 'z')
span_one_end=${alphabet[@]:25:1}
# returns the first letter of the alphabet (always either 'A' or 'a')
span_two_start=${alphabet[@]:0:1}
# returns the letter in the alphabet preceding the input number
span_two_end=${alphabet[@]:$(( $parameter - 1 )):1}

# Build the two character spans
span_one="$span_one_start-$span_one_end"
span_two="$span_two_start-$span_two_end"

# build the translation pattern
translation_pattern="[$span_one$span_two]"

# output translation_pattern
echo $translation_pattern